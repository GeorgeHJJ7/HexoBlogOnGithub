---
title: 浅谈linux线程模型和线程切换
tags:
  - Linux
  - 并发
  - 面试
  - 原创
reward: true
date: 2017-11-29 11:18:06
---

刚开始学习，不一定对，好心人们快来指正我啊啊啊！！！

<!--more-->

# linux线程模型

## 基本模型

首先明确进程组、进程、线程组、线程的概念：

* 操作系统中存在多个进程组
* 一个进程组下有多个进程（1:n）
* 一个进程对应一个线程组（1:1）
* 一个线程组下有多个线程（1:n）

linux用户态的进程、线程基本满足上述概念，但内核态不区分进程和线程。可以认为，内核中统一执行的是进程；但有些是“普通进程”process，有些是“轻量级进程”pthread或npthread；普通进程和轻量级进程都用`task_struct`结构体保存保存，`pthread_create`、`fork`两个系统调用最终都都调用了`do_dork`，而`do_dork`完成了`task_struct`结构体的复制。“普通进程”需要深拷贝虚拟内存、文件描述符、信号处理等，而“轻量级进程”之所以“轻量”，是因为其只需要浅拷贝虚拟内存等大部分信息，多个轻量级进程共享一个进程的资源。

`task_struct`中，使用pgid标的唯一的进程组，tgid标的线程组，pid标的进程或线程。JVM是一个单进程多线程模型，不考虑进程组，则上述概念对应如下：

* 进程组中有一个父进程（主进程），该进程组的pgid等于父进程的pid；进程组下的其他进程都是父进程的子进程，pid不等于pgid
* 线程组中有一个父线程（主线程），该线程组的tgid等于父线程的pid；线程组下的其他线程都是父线程的子线程，tid不等于tgid

举个例子：

| pgid | tgid | pid |
| :--: | :--: | :-: |
| 111  | 111  | 111 |
| 112  | 112  | 112 |
| 112  | 112  | 113 |
| 113  | 113  | 113 |
| 113  | 113  | 114 |
| 113  | 115  | 115 |
| 113  | 115  | 116 |
| 113  | 115  | 117 |

* 存在3个进程组：111、112、113
    * 进程组111下只有一个父进程111
        * 进程111下只有一个父线程111
    * 进程组112下只有一个父进程112
        * 进程112下有一个父线程112，一个子线程113
    * 进程组113下有一个父进程113，一个子进程115
        * 进程113下有一个父线程113，一个子线程114
        * 进程115下有一个父线程115，两个子线程116、117

>更严谨的说，内核中只有“线程”（前面称为“进程”是linux中的习惯），进程只用于管理资源，与具体的执行无关。这就照应了老生常谈的一句话：“进程是资源分配的基本单位，线程是CPU执行的基本单位”。背了多少年的一句话，现在才真的明白。。。

## 更多线程模型

### 一对一

不管是LinuxThreads还是NPTL，均采用一对一的线程模型：一个用户线程对应一个内核线程。内核负责每个线程的调度，可以调度到其他处理器上面。

优点：

* 实现简单。

缺点：

* 对用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换。
* 内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响。

### 多对一

顾名思义，多对一线程模型中，多个用户线程对应到同一个内核线程上：线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。

优点：

* 用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换。使线程的创建、调度、同步等非常快。

缺点：

* 由于多个用户线程对应到同一个内核线程，如果其中一个用户线程阻塞，那么该其他用户线程也无法执行。
* 内核并不知道用户态有哪些线程，无法像内核线程一样实现较完整的调度、优先级等

### 多对多

IBM放弃的NGPT采用了多对多的线程模型。

多对一线程模型是非常轻量的，问题在于多个用户线程对应到固定的一个内核线程。多对多线程模型解决了这一问题：m个用户线程对应到n个内核线程上，通常`m>n`。

优点：

* 兼具多对一模型的轻量
* 由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行
* 由于对应了多个内核线程，则可以实现较完整的调度、优先级等

缺点：

* 实现复杂

# 线程切换

由于linux线程模型是一对一的，用户线程切换与内核线层切换之间的差别非常小。同时，如果忽略用户主动放弃用户线程的执行权（yield）带来的开销，则只需要考虑内核线程切换的开销。

>注意，这里仅仅是为了帮助理解做出的简化。实际上，用户线程库在用户线程的调度、同步等过程中做了很多工作：**如JVM对Thread#yield()的解释，如果底层OS不支持yield的语义，则JVM让用户线程自旋至时间片结束，线程被动切换，以达到相似的效果**。这部分开销不能忽略。

## 什么引起线程切换

* 时间片轮转
* 线程阻塞
* 线程放弃时间片

## 线程切换的开销

### 直接开销

直接开销是线程切换本身引起的，无可避免，必然发生。

#### 上下文切换

前面说线程（或者叫做进程都随意）信息需要用一个`task_struct`保存，线程切换时，必然需要将旧线程的`task_struct`从内核切出，将新线程的切入，带来上下文切换。除此之外，还需要切换寄存器、程序计数器、线程栈（包括操作栈、数据栈）等。

#### 线程调度算法

线程调度算法需要管理线程的状态、等待条件等，如果根据优先级调度，则还需要维护优先级队列。如果线程切换比较频繁，该成本不容小觑。

### 间接开销

间接开销是直接开销的副作用，取决于系统实现和用户代码实现。

#### 缓存缺失

切换进程，需要执行新逻辑。通常情况下，二者的访问的地址空间不相近，则会引起缓存缺失，具体影响范围取决于系统实现和用户代码实现。如果系统的L1、L2缓存较大，则能减少读L3缓存的可能，从而减小缓存缺失的影响；如果用户线程访问数据的地址空间接近，则缓存本身的缺失率就更低。

对页表等快慢表式结构同理。

---

>参考:
>
>* [Linux 线程实现机制分析](https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/)
>* [历史上线程的3种实现模型](https://www.cnblogs.com/yuuyuu/p/5139620.html)
>* [从Java视角理解系统结构(一)CPU上下文切换](http://ifeve.com/java-context-switch/)
>* [从Java视角理解系统结构（二）CPU缓存](http://ifeve.com/from-javaeye-cpu-cache/)
>* [从Java视角理解系统结构（三）伪共享](http://ifeve.com/from-javaeye-false-sharing/)
>
